import { FirewallResult, Scanner, ScannerInput } from '../types.js';
import { makeRequest, createScannerInput } from '../core/request.js';

// Common WAF/firewall signatures in headers
const FIREWALL_SIGNATURES: Record<string, string[]> = {
  'Cloudflare': [
    'cf-ray',
    '__cfduid',
    'cf-request-id',
    'cf-cache-status',
    'cf-connecting-ip',
    'cloudflare',
    'cloudflare-nginx',
    '__cf',
    'cfduid'
  ],
  'Akamai': [
    'x-akamai-transformed',
    'akamai-origin-hop',
    'akamai-global-host',
    'x-akamai',
    'x-check-cacheable',
    'akamai'
  ],
  'Incapsula': [
    'incap_ses',
    'visid_incap',
    'incap_visid_',
    'incapsula',
    'x-iinfo',
    'x-cdn'
  ],
  'Sucuri': [
    'x-sucuri-id',
    'x-sucuri-cache',
    'sucuri',
    'x-sucuri'
  ],
  'ModSecurity': [
    'x-mod-security',
    'modsecurity',
    'mod_security'
  ],
  'AWS WAF': [
    'x-amz-cf-id',
    'x-amz-cf-pop',
    'awselb',
    'aws-alb',
    'x-amz-id',
    'aws'
  ],
  'Fastly': [
    'fastly-io-info',
    'x-fastly',
    'fastly-ssl',
    'fastly',
    'x-served-by'
  ],
  'F5 BIG-IP ASM': [
    'x-wa-info',
    'x-asc',
    'bigip',
    'x-cnection',
    'x-f5'
  ],
  'Barracuda': [
    'x-barracuda',
    'barracuda',
    'barra_counter',
    'barracudacentral'
  ],
  'Imperva': [
    'x-iinfo',
    'x-cdn',
    'imperva',
    '_imp_apg_r_',
    '_imp_di_',
    'imperva_session'
  ],
  'Citrix ADC': [
    'ns_af',
    'citrix_ns_id',
    'ns-cache',
    'ns_tvc',
    'netscaler'
  ],
  'Fortinet/FortiWeb': [
    'fortigate',
    'fortiweb',
    'fortinet',
    'fortiwafsid'
  ],
  'Radware': [
    'x-sl',
    'x-sl-compstate',
    'radware',
    'rwsc'
  ],
  'Wordfence': [
    'wordfence',
    'wfCBLBypass'
  ],
  'SiteLock': [
    'x-sitelock',
    'sitelock-site-verification',
    'sitelock'
  ],
  'Distil Networks': [
    'x-distil-cs',
    'distil_ratelimit',
    'distil'
  ],
  'Reblaze': [
    'rbzid',
    'rbsession',
    'reblaze'
  ]
};

// Common WAF signatures in response content and behaviors
const WAF_BEHAVIOR_SIGNATURES: Record<string, string[]> = {
  'Cloudflare': [
    'cloudflare ray id:', 
    'cloudflare to restrict access',
    'cloudflare security',
    'checking your browser'
  ],
  'Sucuri': [
    'sucuri website firewall',
    'access denied - sucuri website firewall',
    'blocked by the sucuri website firewall'
  ],
  'ModSecurity': [
    'mod_security',
    'this request has been blocked by the mod security',
    'mod_security rules triggered'
  ],
  'AWS WAF': [
    'aws web application firewall',
    'request blocked by web application firewall'
  ],
  'Imperva': [
    'imperva', 
    'incapsula incident id', 
    'your request was blocked by imperva'
  ],
  'Akamai': [
    'akamai reference number',
    'you don\'t have permission to access', 
    'access denied. please try again after'
  ],
  'Wordfence': [
    'wordfence security',
    'site access blocked by wordfence',
    'generated by wordfence',
    'a wordfence firewall blocked'
  ],
  'Barracuda': [
    'barracuda networks',
    'you were blocked by the barracuda web application firewall'
  ],
  'F5 BIG-IP ASM': [
    'request rejected by big-ip',
    'the requested url was rejected',
    'please consult with your administrator'
  ],
  'Fortinet/FortiWeb': [
    'your request was blocked by fortinet',
    'your access to this page has been limited by fortiweb'
  ]
};

// WAF evasion test patterns - These strings often trigger WAF rules when present in requests
const WAF_DETECTION_PAYLOADS = [
  // SQL Injection payloads
  "' OR 1=1 --",
  "1' OR '1'='1",
  // XSS payloads
  "<script>alert(1)</script>",
  "<img src=x onerror=alert('XSS')>",
  // Path traversal
  "../../../etc/passwd",
  // Command injection
  "& cat /etc/passwd",
  "; ls -la",
  // Local File Inclusion
  "file:///etc/passwd",
  // Generic malicious patterns
  "eval(base64_decode",
  "union select password"
];

/**
 * Test if a request is blocked by a WAF
 */
async function testWAFBlocking(
  url: string, 
  timeout: number, 
  headers?: Record<string, string>
): Promise<{ blocked: boolean; response: any; payload: string }> {
  // First, make a normal request to compare with
  const normalResponse = await makeRequest(url, {
    method: 'GET',
    timeout: timeout,
    headers: headers
  }).catch(() => ({ status: 0, headers: {}, data: '' }));
  
  // Try a few detection payloads until one is blocked or we run out
  for (const payload of WAF_DETECTION_PAYLOADS) {
    try {
      // Construct a URL with the payload in a query parameter
      const testUrl = url.includes('?') 
        ? `${url}&waftest=${encodeURIComponent(payload)}` 
        : `${url}?waftest=${encodeURIComponent(payload)}`;
      
      const response = await makeRequest(testUrl, {
        method: 'GET',
        timeout: timeout,
        headers: headers
      }).catch(err => ({
        status: err.response?.status || 0,
        headers: err.response?.headers || {},
        data: err.response?.data || '',
        error: err.message
      }));
      
      // Check if status differs significantly from normal response
      if (
        (normalResponse.status >= 200 && normalResponse.status < 400) && 
        (response.status === 0 || response.status === 403 || response.status === 406 || 
         response.status === 429 || response.status >= 500)
      ) {
        return { 
          blocked: true, 
          response, 
          payload 
        };
      }
      
      // Check response body for WAF block messages
      if (response.data && typeof response.data === 'string') {
        const responseText = response.data.toLowerCase();
        
        const wafTerms = [
          'waf', 'firewall', 'blocked', 'security', 'attack', 'malicious',
          'denied', 'suspicious', 'protection', 'threat', 'detected'
        ];
        
        // If response contains 2+ WAF-related terms, consider it blocked
        if (wafTerms.filter(term => responseText.includes(term)).length >= 2) {
          return { 
            blocked: true, 
            response, 
            payload 
          };
        }
      }
    } catch (error) {
      // Connection errors can also indicate WAF blocking
      return {
        blocked: true,
        response: { 
          status: 0, 
          headers: {}, 
          data: '', 
          error: (error as Error).message 
        },
        payload
      };
    }
  }
  
  return { 
    blocked: false, 
    response: normalResponse,
    payload: '' 
  };
}

/**
 * Detect web application firewall (WAF)
 */
export const detectFirewall: Scanner<FirewallResult> = async (
  input: ScannerInput
) => {
  const startTime = Date.now();
  const normalizedInput = createScannerInput(input);
  const timeout = normalizedInput.timeout || 10000;
  
  try {
    // Make a HEAD request to get headers with minimal data transfer
    const headResponse = await makeRequest(normalizedInput.target, {
      method: 'HEAD',
      timeout: timeout,
      headers: normalizedInput.headers
    });
    
    // Also make a GET request to check response content
    const getResponse = await makeRequest(normalizedInput.target, {
      method: 'GET',
      timeout: timeout,
      headers: normalizedInput.headers
    });
    
    if ((headResponse.error && getResponse.error) || (!headResponse.headers && !getResponse.data)) {
      return {
        status: 'failure',
        scanner: 'firewall',
        error: headResponse.error || getResponse.error || 'Failed to retrieve responses',
        data: {
          detected: false,
          confidence: 0,
          evidence: []
        },
        timeTaken: Date.now() - startTime
      };
    }
    
    // Convert all header names to lowercase for case-insensitive matching
    const allHeaders = {
      ...(headResponse.headers || {}),
      ...(getResponse.headers || {})
    };
    
    const headers = Object.keys(allHeaders).map(key => key.toLowerCase());
    const headerValues = Object.values(allHeaders).map(val => 
      val ? val.toString().toLowerCase() : ''
    );
    
    // Get response content for analysis
    const responseContent = typeof getResponse.data === 'string' 
      ? getResponse.data.toLowerCase() 
      : JSON.stringify(getResponse.data || '').toLowerCase();
    
    let detected = false;
    let detectedFirewall: string | undefined;
    let confidence = 0;
    let evidence: string[] = [];
    
    // Check for firewall signatures in headers
    for (const [firewallName, signatures] of Object.entries(FIREWALL_SIGNATURES)) {
      let matchCount = 0;
      const matchedEvidence: string[] = [];
      
      for (const signature of signatures) {
        const signatureLower = signature.toLowerCase();
        
        // Check header names
        const headerMatch = headers.find(h => h.includes(signatureLower));
        if (headerMatch) {
          matchCount++;
          matchedEvidence.push(`Header name match: ${headerMatch}`);
          continue;
        }
        
        // Check header values
        const valueMatch = headerValues.some(v => v.includes(signatureLower));
        if (valueMatch) {
          matchCount++;
          matchedEvidence.push(`Header value contains: ${signature}`);
          continue;
        }
        
        // Check response content for signatures
        if (responseContent.includes(signatureLower)) {
          matchCount++;
          matchedEvidence.push(`Response body contains: ${signature}`);
        }
      }
      
      // Calculate confidence based on match ratio
      if (matchCount > 0) {
        const signatureConfidence = Math.min(90, Math.round((matchCount / signatures.length) * 100));
        
        if (signatureConfidence > confidence) {
          detected = true;
          detectedFirewall = firewallName;
          confidence = signatureConfidence;
          evidence = matchedEvidence;
        }
      }
    }
    
    // Check response content for WAF-specific messages
    for (const [firewallName, patterns] of Object.entries(WAF_BEHAVIOR_SIGNATURES)) {
      for (const pattern of patterns) {
        if (responseContent.includes(pattern.toLowerCase())) {          const contentConfidence = 95; // Very high confidence for content matches
          
          if (contentConfidence > confidence) {
            detected = true;
            detectedFirewall = firewallName;
            confidence = contentConfidence;
            evidence = [`Response content contains WAF signature: ${pattern}`];
          }
          
          break;
        }
      }
    }
    
    // Additional checks for Server header with known firewall values
    if (allHeaders.server) {
      const serverHeader = (allHeaders.server as string).toLowerCase();
      
      if (serverHeader.includes('cloudflare')) {
        detected = true;
        detectedFirewall = 'Cloudflare';
        confidence = Math.max(confidence, 90);
        evidence.push(`Server header: ${allHeaders.server}`);
      } else if (serverHeader.includes('aws')) {
        detected = true;
        detectedFirewall = 'AWS';
        confidence = Math.max(confidence, 50);
        evidence.push(`Server header: ${allHeaders.server}`);
      } else if (serverHeader.includes('nginx')) {
        // Nginx could be used as reverse proxy for WAF
        if (!detected) {
          detected = true;
          detectedFirewall = 'Possibly Nginx as WAF';
          confidence = 30;
          evidence.push(`Server header: ${allHeaders.server}`);
        }
      } else if (serverHeader.includes('akamai')) {
        detected = true;
        detectedFirewall = 'Akamai';
        confidence = Math.max(confidence, 90);
        evidence.push(`Server header: ${allHeaders.server}`);
      }
    }
    
    // If no firewall detected by passive means, try active probing
    // This is more aggressive but more accurate
    if (!detected || confidence < 50) {
      try {
        // Test if malicious payloads are blocked
        const blockTest = await testWAFBlocking(
          normalizedInput.target,
          Math.min(timeout, 5000), // Use shorter timeout for the test requests
          normalizedInput.headers
        );
        
        if (blockTest.blocked) {
          detected = true;
          
          // If we already have a firewall name but low confidence, keep it
          if (!detectedFirewall) {
            detectedFirewall = 'Unknown WAF';
          }
          
          // Increase confidence based on blocking
          confidence = Math.max(confidence, 80);
          evidence.push(`Blocked suspicious request with payload: ${blockTest.payload}`);
          
          if (blockTest.response.status) {
            evidence.push(`Block response status: ${blockTest.response.status}`);
          }
          
          // Try to identify the WAF from the block response
          if (blockTest.response.data && typeof blockTest.response.data === 'string') {
            const blockResponseText = blockTest.response.data.toLowerCase();
            
            // Check for WAF signatures in block response
            for (const [firewallName, patterns] of Object.entries(WAF_BEHAVIOR_SIGNATURES)) {
              for (const pattern of patterns) {
                if (blockResponseText.includes(pattern.toLowerCase())) {
                  detectedFirewall = firewallName;
                  confidence = 95;
                  evidence.push(`Block response contains signature of: ${firewallName}`);
                  break;
                }
              }
            }
          }
        }
      } catch (error) {
        // Error in active testing, continue with passive results
        evidence.push(`Note: Active testing error: ${(error as Error).message}`);
      }
    }
    
    return {
      status: 'success',
      scanner: 'firewall',
      data: {
        detected,
        name: detectedFirewall,
        confidence,
        evidence
      },
      timeTaken: Date.now() - startTime
    };
  } catch (error) {
    return {
      status: 'failure',
      scanner: 'firewall',
      error: (error as Error).message || 'Unknown error',
      data: {
        detected: false,
        confidence: 0,
        evidence: []
      },
      timeTaken: Date.now() - startTime
    };
  }
};
